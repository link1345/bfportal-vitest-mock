import { Project } from "ts-morph";
import { dirname, resolve } from "node:path";
import { mkdirSync, writeFileSync } from "node:fs";

export interface GenerateOptions {
	sdkPath: string;       // ./sdk/index.d.ts etc
	outPath: string;       // ./test-support/bfportal-vitest-mock.generated.ts
	namespaceName?: string; // default "mod"
}

export function generateModSupport(options: GenerateOptions) {
	const { sdkPath, outPath } = options;
	const namespaceName = options.namespaceName ?? "mod";

	const project = new Project({
		compilerOptions: {
			allowJs: false,
			declaration: false,
		},
		skipAddingFilesFromTsConfig: true,
	});

	const absSdkPath = resolve(sdkPath);
	const source = project.addSourceFileAtPath(absSdkPath);

	const modNs = source.getModule(namespaceName);
	if (!modNs) {
		throw new Error("not the correct file.");
	}

	const fnDecls = modNs.getFunctions();
	const fnNames = Array.from(
		new Set(
			fnDecls
				.map(fn => fn.getName())
				.filter((n): n is string => !!n),
		),
	).sort((a, b) => a.localeCompare(b));

	const outAbs = resolve(outPath);
	const outDir = dirname(outAbs);
	mkdirSync(outDir, { recursive: true });

	const header = `// Auto-generated by bfportal-vitest-mock.
// SDK: ${absSdkPath}
// Do NOT edit this file manually.

import {
  createModMockFor,
  setupGlobalModMock,
  type ModMockFor,
  type ImplMapFor,
} from "bfportal-vitest-mock";

`;

	const bodyLines: string[] = [];

	bodyLines.push("export const modFnNames = [");
	for (const name of fnNames) {
		bodyLines.push(`  "${name}",`);
	}
	bodyLines.push("] as const;\n");

	bodyLines.push("export type ModFnName = (typeof modFnNames)[number];\n");
	bodyLines.push(`export type BfPortalMod = typeof ${namespaceName};\n`);
	bodyLines.push(
		"export type BfPortalModMock = ModMockFor<BfPortalMod, typeof modFnNames>;\n",
	);
	bodyLines.push(
		"export type BfPortalModImpls = ImplMapFor<BfPortalMod, typeof modFnNames>;\n\n",
	);

	bodyLines.push(
		"export const createBfPortalModMock = (impls?: BfPortalModImpls) =>\n" +
		"  createModMockFor<BfPortalMod, typeof modFnNames>(modFnNames, impls ?? {});\n\n",
	);

	bodyLines.push(
		"export const setupBfPortalMock = (impls?: BfPortalModImpls, extra?: Partial<BfPortalMod>) =>\n" +
		"  setupGlobalModMock<BfPortalMod, typeof modFnNames>(modFnNames, impls ?? {}, extra);\n",
	);
	bodyLines.push(
		"export function createFake<T extends (mod.Object | mod.Array)>(): T {\n" +
		"  return { __test: true } as unknown as T;\n" +
		"}\n"
	);

	const content = header + bodyLines.join("\n");
	writeFileSync(outAbs, content, "utf8");
}
